use clap::{App, Arg};
use clap::crate_version;

pub struct CliApp;

impl CliApp {
    pub fn create_cli_app(&self) -> App {
        let app = App::new("chopper")
            .version(crate_version!())
            .about("chopper is a simple streaming time series tool")
            .arg(Arg::with_name("begin")
                .short("b")
                .long("begin")
                .help("set begin timestamp (inclusive); \nformat: 20190830,00:00:00,-0500")
                .takes_value(true)
                .value_name("TIMESTAMP"))
            .arg(Arg::with_name("end")
                .short("e")
                .long("end")
                .help("set end timestamp (exclusive); \nformat: 20190830 00:00:00 -0500")
                .takes_value(true)
                .value_name("TIMESTAMP"))
            .arg(Arg::with_name("backtrace")
                .long("backtrace")
                .help("print backtrace"))
            .arg(Arg::with_name("input")
                .help("sets the input files to use; \n\
            if missing, stdin will be used")
                .multiple(true))
            .arg(Arg::with_name("output")
                .long("output")
                .short("o")
                .help("output to a file")
                .takes_value(true)
                .value_name("FILE"))
            //  below are csv only
            .arg(Arg::with_name("csv_input_delimiter")
                .long("csv-in-delimiter")
                .help("csv only: input field/column delimiter")
                .takes_value(true)
                .default_value(",")
                .value_name("ARG"))
            .arg(Arg::with_name("csv_output_delimiter")
                .long("csv-out-delimiter")
                .help("csv only: output field/column delimiter")
                .takes_value(true)
                .default_value(",")
                .value_name("ARG"))
            .arg(Arg::with_name("csv_has_header")
                .long("csv-has-header")
                .help("csv only: input files have header"))
            .arg(Arg::with_name("csv_print_timestamp")
                .long("csv-print-timestamp")
                .help("csv only: print timestamp as first column")
                .takes_value(true)
                .default_value("auto")
                .possible_values(&["true", "false", "auto"])
                .case_insensitive(true)
                .value_name("ARG"))
            .arg(Arg::with_name("csv_timestamp_col_date")
                .long("csv-timestamp-date")
                .help("csv only: specify the timestamp date column index")
                .takes_value(true)
                .default_value("0")
                .value_name("ARG"))
            .arg(Arg::with_name("csv_timestamp_col_time")
                .long("csv-timestamp-time")
                .help("csv only: specify the timestamp time column index")
                .takes_value(true)
                .value_name("ARG"))
            .arg(Arg::with_name("csv_timestamp_format_date")
                .long("csv-timestamp-format-date")
                .help("csv only: specify the timestamp date format [default: %Y%m%d]")
                .takes_value(true)
                .value_name("ARG")
                .requires("csv_time_zone"))
            .arg(Arg::with_name("csv_timestamp_format_time")
                .long("csv-timestamp-format-time")
                .help("csv only: specify the timestamp time format [default: %H:%M:%S]")
                .takes_value(true)
                .value_name("ARG")
                .requires_all(&["csv_timestamp_format_date", "csv_time_zone"]))
            .arg(Arg::with_name("csv_time_zone")
                .long("csv-time-zone")
                .help("csv only: specify the timestamp time zone")
                .takes_value(true)
                .possible_values(&["UTC", "NY"])
                .case_insensitive(true)
                .value_name("ARG"));
        app
    }
}
